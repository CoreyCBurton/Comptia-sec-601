# Development to production
* How will you deploy it safely and reliably

* Patch Tuesday, Test and deploy Wednesday, or some set day

* Manage the process, safely move from a non-production phase to full production 

# Sandboxing
* Isolated testing environment, no connection to the real world or production system

* Try some code, Break some code, nobody gets hurt

* Incremental development 

# Development
* Secure environment 

* Writing code

* Developers test in their sandboxes

# Test
* Still in the development stage

* All of the pieces are put together 

# Verifying the application
* QA team or quality Assurance; 

* Verifies features are working as expected 

* Staging; Almost ready to roll out, more test

* Working with a copy of production data; Run performance tests

# Using the application
* Application is live, rolled out to the user community

* A challenging step, impacts users 

* Logistical challenges, New servers, New software. Restart or interrupt service 

# Secure baselines 
* All application instances must follow this baseline

* Firewall settings, patch levels, OS file versions

* Find immedate corrections 

# Provisioning 
* Deploy an application, webserver, database server, middleware server, user workstation, certificate updates.

* Application software security, operating system 

* Network security, VLAN, internet access, external access 

# Scalability and elasticity
* HAndle application workload

* Scalability, the ability to increase the workload in a given infrastructure 

* Build an application instrance that can handle 100,000 transactions per second

# Orchestration
* Automation is the key to cloud computing, Services appear and disappear automatically 

* Entire application isntances can be instantly provisioned, All servers, networks, switches, firewalls, and policies

# Deprovisioning 
* Dismantling and removing an application instance

* Security deprovisining is important 

* Firewall policies must be reverted

# Secure coding concepts
* A balance between time and quality

* Testing, Testing, testing, The QA process

# Stores procedure
* SQL databases

* Client requests can be complex

* Stored procedures limit the client interactions

* Allows the user to not make any outside data base calls

# Obfuscation/camouflage
* Make something normally understandable, very difficult to understand

* Only helps prevent the search for humans

# Code reuse/dead code
* Code reuse, copy and paste

* If the old code has security vulnerabilities, reusing the code that spreads to other applications

# Input validation
* What is the expected input, validate actual vs. expected

* Document all input methods

* Check and correct all input (normalization)

* Check and correct all input, A zip code should be only X characters

* Fix any data with improper input

* The fuzzers will find what you missed

# Validatrion points
* Server-side validation, checks occur on the server, Help protect against malicious users

* Client-side validation, The end-user's app makes the validation decisions 

* Can filter legitmate input from genuine users 

# Memory management
* As a developer, you myst be mindful of how memeory is used

* Never trust data input, Malicious user can attempt to circument your code

* Ex - Buffer overflows

# Third-party livraries and SDKs
* Your programming language does everything

* Third-party libraries and software development kits (SDKs) 

* There is a security risk, it was written by someone else 

# Data exposure
* So much sensitive data, Credit card numbers, social security numbers, medical information

* Know how the application is handling data, Encryption and other information

* All input and output process are important 

# Version Control
* Create a file, make a change, make another change

* Commonly used in software development 

* Useful for security

# Exploiting an application
* Attackers often exploit application vulnerabilites

* Once you explout one binary, you can exploit them all

# Software diversity
* Alternative compliter paths would result in a different binary each time

* An attack against different binaries would only be successful on a traction of the users

# Automation and scripting
* Plan for change, implement automatically

* Automated courses of action, many problems can be predicted

* Continous monitoring 

* Configuration validation 

# Continuous integration
* Code is constantly written

* Chances for security problems 

* Basic set of security checks during development 

* Even more security checkes

# Continuous delivery/deployment
* Automate the testing process

* Automate the release process

* Click a button and deploy the application

* Continuous deployment

# Directory services
* Keep all of an organizations username and passwords in a single database

* Large distributed database

* All authentication requests reference this directory





































